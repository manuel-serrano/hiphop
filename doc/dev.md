<!-- ${ var doc = require( "@hop/hopdoc" ) } -->

HipHop Environment
==================

> [!NOTE]
> The source files used in this chapter are avaiable in the HipHop
> [github](https://github.com/manuel-serrano/hiphop/tree/master/examples/web) 
> repository.

Running HipHop programs on the Web
----------------------------------
<!-- [:web@index] -->

In this chapter, we show how to run HipHop programs on a server-side
of an application, e.g., on Nodejs, and on the client-side of a web
application, .e.g., on Firefox. To run the examples, first create a
fresh directory and install HipHop inside it.

```shell
mkdir example
cd example
npm install https://www-sop.inria.fr/members/Manuel.Serrano/software/npmx/hiphop.tgz
```

In the rest of this section we assume the file `abro.hh.js` defined as:

<span class="hopscript">&#x2605;</span> [abro.hh.mjs](../examples/web/abro.hh.mjs)
<!-- ${doc.includeCode("../examples/web/abro.hh.mjs", "hopscript")} -->

### Server-side execution ###

To execute a HipHop program on an unmodified JavaScript execution engines,
let it be Nodejs, Hop, or any other compliant engine, it has to be
compiled first. This is accomplished by the `hhc.mjs` compiler that
is part of the standard HipHop distribution. To compile our `abro.hh.js`
example, one has to use the following command:

```shell
./node_module/@hop/hiphop/bin/hhc.mjs abro.hh.mjs -o abro.mjs
```

This will generate two files:

  * `abro.mjs`, which a standard JavaScript ES6 module.
  * `abro.map.json`, which is a _source map_ file that will let the
  native JavaScript engine refer to source location inside `abro.hh.js`
  instead of `abro.mjs`.

Once, compiled, the program can be imported by any regular ES6 module
and executed using the HipHop API. Example:

<span class="hopscript">&#x2605;</span> [hello.mjs](../examples/web/hello.mjs)
<!-- ${doc.includeCode("../examples/web/hello.mjs", "hopscript")} -->

This program can be executed with:

```shell
nodejs --enable-source-maps hello.mjs 
```

### Client-side execution with a Nodejs server ###

In this section we show how to use HipHop on client-side of web
applications. We show how to proceed to implement a web app executing
the `abro.hh.mjs` reactive program on a web browser. Let's implement a
minimal web server only using the bare
Nodejs' [http](https://nodejs.org/docs/latest/api/http.html) api.

Let us first describe the web page the server delivers.

<span class="xml">&#x2605;</span> [index.html](../examples/web/index.html)
<!-- ${doc.includeCode("../examples/web/index.html", "xml")} -->

The `script type="importmap"` specify a mapping from JavaScript module
names to URL. As such, when the JavaScript code running on the browser
will import the module `@hop/hiphop`, the browser will request the URL
`/hiphop.mjs` to the server (we'll see in a moment how we configure
the server so that it can respond to this request). By specifying a
module-to-URL mapping, we can re-use the same program `abro.mjs`
as the one we use when running on the server, althought the module
`@hop/hiphop` has different implementations for the server and for the
client.

The configuration of the web server is as follows:

<span class="hopscript">&#x2605;</span> [node-server.mjs](../examples/web/node-server.mjs)
<!-- ${doc.includeCode("../examples/web/node-server.mjs", "hopscript")} -->

It is a standard implementation of a web server using Nodejs and contains
no code specific to HipHop.

### Client-side execution with a Hop Server ###

We can simplify the implementation of our simple HipHop web
application by using a [hop](https://github.com/manuel-serrano/hop)
server instead of a plain Nodejs server.

As for the previous example, the Hiphop `abro.hh.mjs` file remain unchanged.
In Hop, the standard way to generate HTML documents is to build them
dynamically using the builtin XML syntax. The HTML page will be then
generated by the `index` function defined as:

<span class="hopscript">&#x2605;</span> [index.hop.mjs](../examples/web/index.hop.mjs)
<!-- ${doc.includeCode("../examples/web/index.hop.mjs", "hopscript")} -->

Before being executed, this module has to be compiled to plain JavaScript

```shell
./node_modules/@hop/hop/bin/hopc index.hop.mjs -o index.mjs
```

The main difference with the static document we have used for Nodejs is
the use of the `R` variable. The Nodejs version was only able to deliver
a fixed set of files and the mapping between URL and files was fixed once
for all at the initialization of the program. Hop uses a more elaborated
mechanism for implementing the mapping. The only useful information here
is that `R` is a bidirectional data structure mapping actual file names
to URL and vice-versa.

The server-side module is defined as follows:

<span class="hopscript">&#x2605;</span> [hop-server.mjs](../examples/web/hop-server.mjs)
<!-- ${doc.includeCode("../examples/web/hop-server.mjs", "hopscript")} -->

Typed HipHop (a.k.a. TypeScript compilation)
--------------------------------------------
<!-- [:TypeScript@index] -->

In this section we show to use add type annotations to HipHop programs
and how to use the TypeScript compiler to detect type errors statically.

The build process is more complex because TypeScript requires all the
sources to be available when it compiles a module (otherwise, it
cannot type-check the module being compiled) and because of the import
rules TypeScript uses. In a TypeScript `import` form, the module file
name designates the name of the generated JavaScript file, not the
name of the TypeScript source file. The last difficulty is to deal with
source-map files. The TypeScript compiler generates source-map but does not
read any. Meaning that if a TypeScript file is generated, the TypeScript 
compiler cannot associates the program it compiles with another source
file. In this section, we show how to use the `hhc`, the HipHop compiler,
and `hopc`, the Hop compiler to solve all these issues.

First let's add type annotations to the `abro` HipHop module. This
typed version is stored in a file named `abro.hh.ts`.

<span class="typescript">&#x2605;</span> [abro.hh.ts](../examples/typescript/abro.hh.ts)
<!-- ${doc.includeCode("../examples/typescript/abro.hh.ts", "typescript")} -->

This file has to be compiled in two steps. First, it has to be compiled
to plain TypeScript.

```shell
./node_module/@hop/hiphop/bin/hhc.mjs abro.hh.mjs -o abro.ts
```

and the, using the `hopc` compiler into a plain JavaScript file. The `hopc`
compiler is a mere wrapper around the `tsc` compiler. To let `tsc` generates
a JavaScript ES module instead of the CommonJS module, there must be
a `package.json`. For instance:

<span class="json">&#x2605;</span> [abro.hh.ts](../examples/typescript/package.json)
<!-- ${doc.includeCode("../examples/typescript/package.json", "json")} -->


The declaration `"type": "module"` tells `tsc` to generate an ES module. The
compilation is executed with:

```shell
./node_module/@hop/hiphop/bin/hopc.mjs abro.ts -o abro.mjs
```

> [!NOTE]
> We compiled `hopc` instead of `tsc` for compiling the generated TypeScript
> file, because `hopc` is able to deal with multiple source-map file, so that
> the file `abro.map.json` that will get generated will correctly map any
> possible runtime erroor into the orignal `abro.hh.ts` file. If we had used
> `tsc` instead, the generated `abro.map.json` file would have pointed to
> `abro.ts` instead.

Let us assume a main program that imports the HipHop machine:

<span class="typescript">&#x2605;</span> [hello.ts](../examples/typescript/hello.ts)
<!-- ${doc.includeCode("../examples/typescript/hello.ts", "typescript")} -->

This program can be compiled and executed with:

```shell
./node_module/@hop/hiphop/bin/hopc.mjs hello.ts -o hello.mjs
node --enable-source-maps hello.mjs
```


The Net List
------------

The HipHop compiler generates a net list from a HipHop source using
the technique described in [The Constructive Semantics of Pure
Esterel](http://www-sop.inria.fr/members/Gerard.Berry/Papers/EsterelConstructiveBook.pdf).
This compiled program can be executed by simulating the generated
circuit. The tools `tools/nets2dot.mjs` can be used in conjunction
with the [dot](https://graphviz.org) graph visualizer to generate PDF
files. Here is how to proceed for generating these files, considering
a HipHop source file named `foo.hh.js`:

  1. Add the option `{ dumpNets: true }` to the reactive machine for 
  which you want to dump the net list.
  2. Run your program. This will generate two files: `foo.hh.js.nets-.json`
  and `foo.hh.js.nets+.json`. The former is the net list before optimizations
  the latter after optimizations.
  3. Generate the `.dot` files:
    - bin/nets2dot.js foo.hh.js.nets-.json > nets-.dot
    - bin/nets2dot.js foo.hh.js.nets+.json > nets+.dot
  4. Generate the PDF files:
    - dot -T pdf nets-.dot > nets-.pdf
    - dot -T pdf nets+.dot > nets+.pdf

The main syntax of the `json` files representing the net lists is as follows:


```bnf
NETLIST ::= {
  "filename": STRING, # the name fo the source file of the main hiphop module
  "sweep": BOOL,      # true iff the sweep optimization is enabled
  "nets": [ NET, ..., NET ] # the actual net list
}

```

The syntax of the `NET` is as follows.

```bnf
NET ::= {
  "id": INTEGER,      # a unique identifier
  "lvl": INTEGER,     # the re-incarnation level (used for loops)
  "type": NET-TYPE,   # the type of the net
  "fanout": [FAN, ... FAN], # the out nets of this net
  "fanin": [FAN, ... FAN]   # the int nets of this net
}

NET-TYPE ::= "REG"
  | "SIG"
  | "TRUE"
  | "FALSE"
  | "AND"
  | "OR"
  | "ACTION"
  | "ACTION-"
  | "SIGACTION"
  | "SIGACTION-"

FAN ::= {
  "id": INTEGER,      # the net the fan points to
  "polarity": BOOL,   # the polarity of the connection
  "dep": BOOL         # true iff a signal dependency
}
```

Nets have also pre-type extra fields.

```bnf
NET-REG ::= {         # fields available withe type == "REG"
  ...
  value: BOOL         # the initial value of the register
}

NET-SIG ::= {         # fields available withe type == "SIG"
  ...
  signame: STRING     # the name of the associated signal
  accessibility: INTEGER # 1: IN, 2: OUT, 3: INOUT, 4: LOCAL
}

NET-SIG ::= {         # fields available withe type == "SIG"
  ...
  signame: STRING     # the name of the associated signal
  accessibility: INTEGER # 1: IN, 2: OUT, 3: INOUT, 4: LOCAL
}

NET-SIGACTION ::= {   # fields available withe type == "SIGACTION"
  ...
  signal: STRING      # the name of the emitted signal
}
```

> [!NOTE]
> Finally, `json` structures might contain extra private fields whose names
> start with the `$` characters. These fields are used for better visualizations
> of the net list but they are not required to execute of optimize the net
> lists.
  
Example. Let us consider the P15 example found in page 75 of 
[The Constructive Semantics of Pure Esterel](http://www-sop.inria.fr/members/Gerard.Berry/Papers/EsterelConstructiveBook.pdf). In HipHop this program
is implemented as:

<span class="typescript">&#x2605;</span> [p15.hh.js](../examples/netlist/p15.hh.hs)
<!-- ${doc.includeCode("../examples/netlist/p15.hh.js", "javascript")} -->

The generated net list is:

<span class="json">&#x2605;</span> [p15.net.json](../examples/netlist/p15.net.json)
<!-- ${doc.includeCode("../examples/netlist/p15.net.json", "json")} -->
