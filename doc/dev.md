<!-- ${ var doc = require( "hopdoc" ) } -->

HipHop Environment
==================

> [!NOTE]
> The source files used in this chapter are avaiable in the HipHop
> [github](https://github.com/manuel-serrano/hiphop/tree/master/examples/web) 
> repository.

Running HipHop programs on the Web
----------------------------------
<!-- [:web@index] -->

In this chapter, we show how to run HipHop programs on a server-side
of an application, e.g., on Nodejs, and on the client-side of a web
application, .e.g., on Firefox. To run the examples, first create a
fresh directory and install HipHop inside it.

```shell
mkdir example
cd example
npm install https://www-sop.inria.fr/members/Manuel.Serrano/software/npmx/hiphop.tgz
```

In the rest of this section we assume the file `abro.hh.js` defined as:

<span class="hopscript">&#x2605;</span> [abro.hh.mjs](../examples/web/abro.hh.mjs)
<!-- ${doc.includeCode("../examples/web/abro.hh.mjs", "hopscript")} -->

### Server-side execution ###

To execute a HipHop program on an unmodified JavaScript execution engines,
let it be Nodejs, Hop, or any other compliant engine, it has to be
compiled first. This is accomplished by the `hhc.mjs` compiler that
is part of the standard HipHop distribution. To compile our `abro.hh.js`
example, one has to use the following command:

```shell
./node_module/@hop/hiphop/bin/hhc.mjs abro.hh.mjs -o abro.mjs
```

This will generate two files:

  * `abro.mjs`, which a standard JavaScript ES6 module.
  * `abro.map.json`, which is a _source map_ file that will let the
  native JavaScript engine refer to source location inside `abro.hh.js`
  instead of `abro.mjs`.

Once, compiled, the program can be imported by any regular ES6 module
and executed using the HipHop API. Example:

<span class="hopscript">&#x2605;</span> [hello.mjs](../examples/web/hello.mjs)
<!-- ${doc.includeCode("../examples/web/hello.mjs", "hopscript")} -->

This program can be executed with:

```shell
nodejs --enable-source-maps hello.mjs 
```

### Client-side execution with a Nodejs server ###

In this section we show how to use HipHop on client-side of web
applications. We show how to proceed to implement a web app executing
the `abro.hh.mjs` reactive program on a web browser. Let's implement a
minimal web server only using the bare
Nodejs' [http](https://nodejs.org/docs/latest/api/http.html) api.

Let us first describe the web page the server delivers.

<span class="xml">&#x2605;</span> [index.html](../examples/web/index.html)
<!-- ${doc.includeCode("../examples/web/index.html", "xml")} -->

The `script type="importmap"` specify a mapping from JavaScript module
names to URL. As such, when the JavaScript code running on the browser
will import the module `@hop/hiphop`, the browser will request the URL
`/hiphop.mjs` to the server (we'll see in a moment how we configure
the server so that it can respond to this request). By specifying a
module-to-URL mapping, we can re-use the same program `abro.mjs`
as the one we use when running on the server, althought the module
`@hop/hiphop` has different implementations for the server and for the
client.

The configuration of the web server is as follows:

<span class="hopscript">&#x2605;</span> [node-server.mjs](../examples/web/node-server.mjs)
<!-- ${doc.includeCode("../examples/web/node-server.mjs", "hopscript")} -->

It is a standard implementation of a web server using Nodejs and contains
no code specific to HipHop.

### Client-side execution with a Hop Server ###

We can simplify the implementation of our simple HipHop web
application by using a [hop](https://github.com/manuel-serrano/hop)
server instead of a plain Nodejs server.

As for the previous example, the Hiphop `abro.hh.mjs` file remain unchanged.
In Hop, the standard way to generate HTML documents is to build them
dynamically using the builtin XML syntax. The HTML page will be then
generated by the `index` function defined as:

<span class="hopscript">&#x2605;</span> [index.hop.mjs](../examples/web/index.hop.mjs)
<!-- ${doc.includeCode("../examples/web/index.hop.mjs", "hopscript")} -->

Before being executed, this module has to be compiled to plain JavaScript

```shell
./node_modules/@hop/hop/bin/hopc index.hop.mjs -o index.mjs
```

The main difference with the static document we have used for Nodejs is
the use of the `R` variable. The Nodejs version was only able to deliver
a fixed set of files and the mapping between URL and files was fixed once
for all at the initialization of the program. Hop uses a more elaborated
mechanism for implementing the mapping. The only useful information here
is that `R` is a bidirectional data structure mapping actual file names
to URL and vice-versa.

The server-side module is defined as follows:

<span class="hopscript">&#x2605;</span> [hop-server.mjs](../examples/web/hop-server.mjs)
<!-- ${doc.includeCode("../examples/web/hop-server.mjs", "hopscript")} -->

Typed HipHop (a.k.a. TypeScript compilation)
--------------------------------------------
<!-- [:TypeScript@index] -->

In this section we show to use add type annotations to HipHop programs
and how to use the TypeScript compiler to detect type errors statically.

The build process is more complex because TypeScript requires all the
sources to be available when it compiles a module (otherwise, it
cannot type-check the module being compiled) and because of the import
rules TypeScript uses. In a TypeScript `import` form, the module file
name designates the name of the generated JavaScript file, not the
name of the TypeScript source file. The last difficulty is to deal with
source-map files. The TypeScript compiler generates source-map but does not
read any. Meaning that if a TypeScript file is generated, the TypeScript 
compiler cannot associates the program it compiles with another source
file. In this section, we show how to use the `hhc`, the HipHop compiler,
and `hopc`, the Hop compiler to solve all these issues.

First let's add type annotations to the `abro` HipHop module. This
typed version is stored in a file named `abro.hh.ts`.

<span class="typescript">&#x2605;</span> [abro.hh.ts](../examples/typescript/abro.hh.ts)
<!-- ${doc.includeCode("../examples/typescript/abro.hh.ts", "typescript")} -->

This file has to be compiled in two steps. First, it has to be compiled
to plain TypeScript.

```shell
./node_module/@hop/hiphop/bin/hhc.mjs abro.hh.mjs -o abro.ts
```

and the, using the `hopc` compiler into a plain JavaScript file. The `hopc`
compiler is a mere wrapper around the `tsc` compiler. To let `tsc` generates
a JavaScript ES module instead of the CommonJS module, there must be
a `package.json`. For instance:

<span class="json">&#x2605;</span> [abro.hh.ts](../examples/typescript/package.json)
<!-- ${doc.includeCode("../examples/typescript/package.json", "json")} -->


The declaration `"type": "module"` tells `tsc` to generate an ES module. The
compilation is executed with:

```shell
./node_module/@hop/hiphop/bin/hopc.mjs abro.ts -o abro.mjs
```

> [!NOTE]
> We compiled `hopc` instead of `tsc` for compiling the generated TypeScript
> file, because `hopc` is able to deal with multiple source-map file, so that
> the file `abro.map.json` that will get generated will correctly map any
> possible runtime erroor into the orignal `abro.hh.ts` file. If we had used
> `tsc` instead, the generated `abro.map.json` file would have pointed to
> `abro.ts` instead.

Let us assume a main program that imports the HipHop machine:

<span class="typescript">&#x2605;</span> [hello.ts](../examples/typescript/hello.ts)
<!-- ${doc.includeCode("../examples/typescript/hello.ts", "typescript")} -->

This program can be compiled and executed with:

```shell
./node_module/@hop/hiphop/bin/hopc.mjs hello.ts -o hello.mjs
node --enable-source-maps hello.mjs
```


Visualizing the Net List
------------------------

The HipHop compiler generates a net list from a HipHop source. This compiled
program can be executed by simulating the generated circuit. The tools
`tools/nets2dot.mjs` can be used in conjunction with the 
[dot](https://graphviz.org) graph visualizer to generate PDF files.
Here is how to proceed for generating these files, considering a HipHop
source file named `foo.hh.js`:

  1. Add the option `{ dumpNets: true }` to the reactive machine for 
  which you want to dump the net list.
  2. Run your program. This will generate two files: `foo.hh.js.nets-.json`
  and `foo.hh.js.nets+.json`. The former is the net list before optimizations
  the latter after optimizations.
  3. Generate the `.dot` files:
    - bin/nets2dot.js foo.hh.js.nets-.json > nets-.dot
    - bin/nets2dot.js foo.hh.js.nets+.json > nets+.dot
  4. Generate the PDF files:
    - dot -T pdf nets-.dot > nets-.pdf
    - dot -T pdf nets+.dot > nets+.pdf
