/*=====================================================================*/
/*    serrano/prgm/project/hiphop/hiphop/testrandom/test.mjs           */
/*    -------------------------------------------------------------    */
/*    Author      :  robby findler & manuel serrano                    */
/*    Creation    :  Tue May 27 14:05:43 2025                          */
/*    Last change :  Sun Jun  1 13:13:06 2025 (serrano)                */
/*    Copyright   :  2025 robby findler & manuel serrano               */
/*    -------------------------------------------------------------    */
/*    HipHop Random Testing entry point.                               */
/*=====================================================================*/
import * as hh from "../lib/hiphop.js";
import { makeProp } from "./prop.mjs";
import { gen } from "./gen.mjs";
import { shrinker } from "./shrink.mjs";
import { jsonToHiphop, jsonToAst } from "./dump.mjs";
import { parse } from "../preprocessor/parser.js";
import { existsSync, readFileSync, writeFileSync } from "node:fs";

/*---------------------------------------------------------------------*/
/*    prop ...                                                         */
/*---------------------------------------------------------------------*/
export const prop = makeProp(
   prg => new hh.ReactiveMachine(prg, { name: "colin-no-sweep", verbose: -1, sweep: 0 }),
   prg => new hh.ReactiveMachine(prg, { name: "colin-sweep-wire", verbose: -1, sweep: -1 }),
   prg => new hh.ReactiveMachine(prg, { name: "colin-sweep", verbose: -1 }),
   prg => new hh.ReactiveMachine(prg, { name: "new", compiler: "new", unrollLoops: true, syncReg: true, verbose: -1 }),
/*    prg => new hh.ReactiveMachine(prg, { name: "new-nounroll", compiler: "new", unrollLoops: false, syncReg: true }) */
);

/*---------------------------------------------------------------------*/
/*    shrinkProgram ...                                                */
/*---------------------------------------------------------------------*/
function shrinkProgram(prog) {
   const progs = shrinker(prog);

   if (progs.length === 0) {
      return prog;
   } else {
      for (let i = 0; i < progs.length; i++) {
	 if (prop(progs[i]).status === "failure") {
	    // we still have an error
	    return shrinkProgram(progs[i]);
	 }
      }
      return prog;
   }
}

/*---------------------------------------------------------------------*/
/*    findBugInProg ...                                                */
/*---------------------------------------------------------------------*/
function findBugInProg(out, prog, events) {
   const res = prop(prog);

   if (res.status === "failure") {
      const shrunk = shrinkProgram(prog);
      const sres = prop(shrunk);

      const headers = [
	 `${res.machines[0].name()} / ${res.machines[1].name()}`,
	 sres.msg
      ];

      out(res.machines[1], headers, shrunk, events);
      process.exit(0);
   } else {
      ;
   }
}
   
/*---------------------------------------------------------------------*/
/*    findBugGen ...                                                   */
/*---------------------------------------------------------------------*/
function findBugGen(out, iterCount = 1000) {
   for (let i = 0; i < iterCount; i++) {
      const events = Array.from({length: 10}).map(i => { return {}; });
      const prog = gen();
      console.error("#", i);

      findBugInProg(out, prog, events);
   }
}

/*---------------------------------------------------------------------*/
/*    main                                                             */
/*---------------------------------------------------------------------*/
async function main(argv) {
   
   function outSource(mach, headers, prog, events) {
      const json = prog.tojson();
      
      console.log("// generated by testrandom");
      headers.forEach(h => console.log(`// ${h}`));
      console.log(`
import * as hh from "@hop/hiphop";
		     
const events = ${JSON.stringify(events)};

const prg = hiphop ${jsonToHiphop(json, 0)}

const opts = { name: "${mach.name()}", compiler: "${mach.compiler}", unrollLoop: ${mach.unrollLoop}, syncReg: ${mach.syncReg}, verbose: ${mach.verbose || 0} };
export const mach = new hh.ReactiveMachine(prg, opts);
mach.outbuf = "";
events.forEach((e, i) => mach.outbuf += (i + ': ' + JSON.stringify(mach.react(e)) + '\\n'));
console.log(mach.outbuf);`);
	 console.log("");
console.log(`// HIPHOP_SYNCREG=false HIPHOP_REINCARNATION=true xHIPHOP_SWEEP=-1 HIPHOP_COMPILER=int HIPHOP_UNROLL=false  NODE_OPTIONS="--enable-source-maps --no-warnings --loader @hop/hiphop/lib/hiphop-loader.mjs" node bug.hh.mjs`);
console.log(`// HIPHOP_SYNCREG=${mach.syncReg ? "true" : "false"} HIPHOP_REINCARNATION=${mach.compiler === "new" ? "false" : "true"} xHIPHOP_SWEEP=-1 HIPHOP_COMPILER=${mach.compiler} HIPHOP_UNROLL=${mach.unrollLoop ? "true" : "false"} NODE_OPTIONS="--enable-source-maps --no-warnings --loader @hop/hiphop/lib/hiphop-loader.mjs" node bug.hh.mjs`);
   }

   function outJson(mach, headers, prog, events) {
      const json = prog.tojson();
      
      writeFileSync("/tmp/prog.hh.json", JSON.stringify({ events: events, prog: json }));
   }

   function out(mach, headers, prog, events) {
      outSource(mach, headers, prog, events);
      outJson(mach, headers, prog, events);
   }
   
   if (argv.length < 3) {
      findBugGen(out);
   } else if (existsSync(argv[2])) {
      const { events, prog } = JSON.parse(readFileSync(argv[2]));
      console.error("prog=", jsonToHiphop(prog));
      findBugInProg(outSource, jsonToAst(prog), events);
   } else {
      throw new Error(`Illegal command line: "${argv.join(" ")}"`);
   }
}

/*---------------------------------------------------------------------*/
/*    toplevel ...                                                     */
/*---------------------------------------------------------------------*/
main(process.argv);
