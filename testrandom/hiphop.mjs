/*=====================================================================*/
/*    serrano/prgm/project/hiphop/hiphop/testrandom/hiphop.mjs         */
/*    -------------------------------------------------------------    */
/*    Author      :  Manuel Serrano                                    */
/*    Creation    :  Fri Oct 24 16:29:15 2025                          */
/*    Last change :  Wed Jan  7 19:09:20 2026 (serrano)                */
/*    Copyright   :  2025-26 Manuel Serrano                            */
/*    -------------------------------------------------------------    */
/*    Testing HipHop programs with Hiphop                              */
/*=====================================================================*/

/*---------------------------------------------------------------------*/
/*    The module                                                       */
/*---------------------------------------------------------------------*/
import * as hh from "../lib/hiphop.js";
import * as parser from "../preprocessor/parser.js"
import * as hhast from "../lib/ast.js"
import { Parser, ast, list, generate } from "@hop/hopc";
import { jsonToAst } from "./json.mjs";
import { existsSync, readFileSync, writeFileSync, chmodSync } from "node:fs";

export { ReactiveMachine } from "../lib/hiphop.js";
export { jsonToHiphop };

/*---------------------------------------------------------------------*/
/*    outConf ...                                                      */
/*---------------------------------------------------------------------*/
hh.ReactiveMachine.prototype.outConf = function(suffix, {prog, events}) {
   const target = this.name() + suffix + ".hh.mjs";
   const json = prog.tojson();
   let buf = "#!/bin/env -S node --enable-source-maps --no-warnings --loader @hop/hiphop/lib/hiphop-loader.mjs\n"
   buf += `// generated by testrandom (${hh.version} - ${hh.buildid})`;
   
   buf += (`
import * as hh from "@hop/hiphop";

const events = ${JSON.stringify(events)};

const prg = hiphop ${jsonToHiphop(json, 0)}

const opts = process.env.HIPHOP_TEST === "reincarnation"
   ? { name: "rnca", loopUnroll: false, reincarnation: true, native: false }
   : (process.env.HIPHOP_TEST === "unroll"
      ? { name: "unroll", loopUnroll: true, reincarnation: false, native: false }
      : ${JSON.stringify(this.opts)});
export const mach = new hh.ReactiveMachine(prg, opts);
mach.outbuf = "";

try {
   events.forEach((e, i) => {
      mach.outbuf += (mach.name() + '[' + i + ']: '
         + JSON.stringify(mach.reactDebug(e)) + '\\n')
   });
} finally {
   console.log(mach.outbuf);
}
`);

   buf += "\n";
   buf += `// NODE_OPTIONS="--enable-source-maps --no-warnings --loader @hop/hiphop/lib/hiphop-loader.mjs" node ${target}\n`;

   writeFileSync(target, buf);
   chmodSync(target, "777");
   return target;
}
   
/*---------------------------------------------------------------------*/
/*    margins ...                                                      */
/*---------------------------------------------------------------------*/
const margins = [ "", " ", "  ", "   ", "    ", "     ", "      "];

/*---------------------------------------------------------------------*/
/*    margin ...                                                       */
/*---------------------------------------------------------------------*/
function margin(m) {
   if (m >= margins.length) {
      margins[m] = Array.from({length: m}).map(i => " ").join("");
   }
   return margins[m];
}

/*---------------------------------------------------------------------*/
/*    jsonToHiphop ...                                                 */
/*---------------------------------------------------------------------*/
function jsonToHiphop(obj, m = 0) {
   const { node, children } = obj;

   function block(obj, margin) {
      if (obj.node === "seq") {
	 return obj.children.map(o => jsonToHiphop(o, margin)).join('\n');
      } else {
	 return jsonToHiphop(obj, margin);
      }
   }

   function test(obj) {
      if (typeof obj === "string") {
	 return obj.replace(/^this[.]/, "");
      } else {
	 switch (obj?.node) {
	    case "unary":
	       return `${obj.op}${test(obj.expr)}`;
	    case "binary":
	       return `(${test(obj.lhs)} ${obj.op} ${test(obj.rhs)})`;
	    case "sig":
	       return `${obj.value.replace(/this[.]/, "")}.${obj.prop}`;
	    default: 
	       console.error("*** ERROR:test: illegal object", obj);
	       throw TypeError("Illegal test: " + obj);
	 }
      }
   }
   
   switch (node) {
      case "module":
	 return margin(m) + 'module() {\n'
	    + (obj.signals.length > 0 ? (margin(m + 2) + "inout " + obj.signals.map(s => `${s} = 10 combine (x, y) => (x + y)`).join(", ") + ";\n") : "")
	    + children.map(c => jsonToHiphop(c, m + 2)).join(';\n')
	    + '\n' + margin(m) + '}';

      case "nothing":
	 return margin(m) + ';';

      case "pause":
	 return margin(m) + 'yield;';

      case "seq":
	 if (children.length === 0) {
	    return "";
	 } else {
	    return margin(m) + '{\n'
	       + children.map(c => jsonToHiphop(c, m + 2)).join('\n')  
	       + '\n' + margin(m) + '}';
	 }

      case "par":
	 if (children.length === 0) {
	    return margin(m) + 'fork {}';
	 } else {
	    return margin(m) + 'fork {\n'
	       + jsonToHiphop(children[0], m + 2)
	       + '\n' + margin(m) + '}'
	       + children
		  .slice(1, children.length)
		  .flatMap(c => ` par {\n${jsonToHiphop(c, m + 2)}\n${margin(m)}}`).join('');
	 }

      case "loop":
	 return margin(m) + 'loop {\n'
	    + children.map(c => jsonToHiphop(c, m + 2)).join(';\n')
	    + '\n' + margin(m) + '}';

      case "trap":
	 return margin(m) + `${obj.trapName}: {\n`
	    + children.map(c => jsonToHiphop(c, m + 2)).join(';\n')
	    + '\n' + margin(m) + '}';

      case "exit":
	 return margin(m) + `break ${obj.trapName};`;

      case "halt":
	 return margin(m) + `halt;`;

      case "emit":
	 return margin(m) + `emit ${obj.signame}(${obj.value});`;
	 
      case "local":
	 return margin(m) + '{\n'
	    + (margin(m + 2) + "signal " + obj.signals.map(s => `${s} = 11 combine (x, y) => (x + y)`).join(", ") + ";\n")
	    + children.map(c => jsonToHiphop(c, m + 2)).join('\n') + '\n'
	    + margin(m) + '}';

      case "if":
	 return margin(m) + `if (${test(obj.func)}) {\n`
	    + block(children[0], m + 2) + '\n'
	    + margin(m) + "} else {\n"
	    + block(children[1], m + 2) + '\n'
	    + margin(m) + '}';
	 
      case "abort":
	 return margin(m) + `abort {\n`
	    + block(children[0], m + 2) + '\n' 
	    + margin(m) + `} when (${test(obj.func)})`;
	 
      case "suspend":
	 return margin(m) + `suspend {\n`
	    + block(children[0], m + 2) + '\n' 
	    + margin(m) + `} when (${test(obj.func)})`;
	 
      case "every":
	 return margin(m) + `every (${test(obj.func)}) {\n`
	    + block(children[0], m + 2) + '\n' 
	    + margin(m) + '}';
	 
      case "loopeach":
	 return margin(m) + `do {\n`
	    + block(children[0], m + 2) + '\n' 
	    + margin(m) + `} every (${test(obj.func)});`;
	 
      case "await":
	 return margin(m) + `await (${test(obj.func)})`;
	 
      case "atom":
	 return margin(m) + `pragma { ${obj.func}; }`;
   }
}
